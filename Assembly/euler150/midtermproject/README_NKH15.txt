--SUMMARY--

The general approach I took for the project was essentially an optimized brute-force algorithm.
My algorithm was brute force in the sense that I summed up every triangle to check for which one had the smallest sum but optimized in the sense that no unnecessary summing was done and the minimum subtriangle sum was able to be found in one “pass” of the triangle. I looped through the whole input array, and for each element, I calculated the minimum subtriangle sum by comparing the sums from, in order, from the smallest subtriangle to the biggest legal subtriangle that had the given element at its apex. This allowed me to simply add a row onto each subtriangle. For example, for the first element, and the first test case with four rows, I computed the sum of the subtriangle of size 1 (trivial: I set the sum equal to it), the subtriangle of size 3 (consisting of the two triangle rows directly below it), the subtriangle of size 6, and the subtriangle of size 10 (i.e. the entire triangle), and continued on through the rest of the triangle. Obviously, as you increase the index, the number of subtriangles that you sum gets smaller, until eventually you reach the last row where the only subtriangles are those of size 1.
The indexing required to create a logical 2D array out of a 1D array was not trivial and deserves some discussion. (As an aside, all my indexing was done on the original array so I had to account for the offset of 1 caused by the first element being the depth). The way I chose to approach the problem was to linearly progress through the array by having a counter that incremented for every element but enclose this linear progression in two nested for loops that created a phantom i and j coordinate so that I could index the subtriangles as related to the current element in a logical way.  Within this code, I had two more nested for loops that calculated, with the current i and j value given by the outer nested for loop, a way to course through all of the subtriangles for a given coordinate. I did this by setting the sum and the min of the first subtriangle of size 1 of at that index (i.e. sum=min=triangle[i]). Then I had a nested for loop with an x and a y coordinate corresponding to the row and the column respectively of the element I want to access for addition to the subtriangle, and I had x span the next row (i+1) to the last row (depth-1), and y span the current j index to x – i + j -1.  If I’m being completely frank, the way I chose the endpoint for the y coordinate was a result of trial and error, so I couldn’t give you a logical or mathematical justification for it. I also created a function that maps this weird XY coordinate to an index in the linear 1D array using (row+1)*(row))/2)+col+1. I compared the min on each round of the x coordinate loop, and for each element in the triangle, I stored the resulting min in an array of mins. At the end of the whole program, I found the minimum of this array of mins and returned it as a result. 
If you still have no idea what I mean, just email me at nkh15@pitt.edu and I’ll send you the Java code that probably explains it better than I can.
